from random import randint, shuffle 
from copy import copy

from ..word import Signature, Word
from ..generators import Generators
from ..automorphism import Automorphism
from ..factors import PeriodicFactor, InfiniteFactor

__all__ = ['random_signature', 'random_simple_word', 'random_basis',
	'random_automorphism', 'random_conjugate_pair',
	'random_conjugate_factors', 'random_conjugate_periodic_factors', 'random_conjugate_infinite_factors']

def needs_defaults(undec):
	def decd(num_expansions=None, signature=None):
		if num_expansions is None:
			num_expansions = randint(1, 5)
		if signature is None:
			signature = random_signature()
		return undec(num_expansions, signature)
	decd.__doc__ = undec.__doc__
	return decd

def random_signature():
	r"""Randomly generates a :class:`~thompson.word.Signature` :math:`(n, r)` for use in the functions below. The values of :math:`n` and :math:`r` are chosen (uniformly) at random from :math:`n \in \{2, 3, 4\}` and :math:`r \in \{1, 2, 3, 4, 5\}`, respectively.
	
	.. note:: This function is used to select a random signature when no *signature* argument is provided to the following random functions.
	"""
	return Signature(randint(2, 4), randint(1, 5))

def random_simple_word(signature=None):
	r"""Randomly generates a :meth:`simple <thompson.word.Word.is_simple>` :class:`~thompson.word.Word` belonging to the algebra with the given *signature*. The word consists of an :math:`x_i` followed by 0--15 descendant operators :math:`\alpha_j`. The length and the index of each :math:`\alpha_j` is chosen (uniformly) at random.
	
		>>> random_simple_word().is_simple()
		True
	"""
	signature = signature or random_signature()
	letters = []
	base = randint(1, signature.alphabet_size)
	letters.append(base)
	
	num_alphas = randint(0, 15)
	for i in range(num_alphas):
		letters.append(-randint(1, signature.arity))
	return Word(letters, signature, preprocess=False)

@needs_defaults
def random_basis(num_expansions, signature):
	r"""Randomly generates a basis for the algebra with the given *signature* :math:`(n,r)`. The basis is generated by expanding the :meth:`~thompson.generators.Generators.standard_basis` *num_expansions* times. The expansion point is chosen (uniformly) at random each time. If *num_expansions* is not provided, a value from :math:`\{1, 2, 3, 4, 5\}` is chosen (uniformly) at random.
	
		>>> random_basis().is_basis()
		True
	
	.. note:: This does not generate *bases* uniformly at random. For instance, take :math:`V_{n,r} = V_{2,1}` and let *num_expansions = 3*. The first expansion always gives the basis :math:`[x\alpha_1, x\alpha_2]`. Expanding this twice produces give six bases, one of which appears twice. (To see this, enumeate the rooted binary trees with four leaves.)
	"""
	basis = Generators.standard_basis(signature)
	
	for _ in range(num_expansions):
		i = randint(0, len(basis) - 1)
		basis.expand(i)
	return basis

@needs_defaults
def random_automorphism(num_expansions, signature):
	"""Randomly generates an automorphism for the algebra with the given signature. Two bases *domain* and *range* are generated by :func:`random_basis`; then *range* is :func:`randomly shuffled <py3:random.shuffle>`. An automorphism is returned which maps the elements of *domain* to those of *range* in order.
	
	..note :: The bases may be reduced when the automorphism is created (if they contain redundancy.
	"""
	domain = random_basis(num_expansions, signature)
	range  = random_basis(num_expansions, signature)
	shuffle(range)
	return Automorphism(domain, range)

@needs_defaults
def random_conjugate_pair(num_expansions, signature):
	r"""Calls :func:`random_automorphism` to create two automorphisms :math:`\psi` and :math:`\rho`. Returns the pair :math:`(\psi, \rho^{-1}\psi\rho)`, which are conjugate by definition."""
	psi = random_automorphism(num_expansions, signature)
	rho = random_automorphism(num_expansions, signature)
	phi = ~rho * psi * rho
	return psi, phi

@needs_defaults
def random_conjugate_factors(num_expansions, signature):
	r"""Calls :func:`random_conjugate_pair` to create two automorphisms :math:`\psi` and :math:`\phi`. Returns the :meth:`~thompson.automorphism.Automorphism.free_factors` :math:`\psi_P, \psi_I, \phi_P, \phi_I.`
	
	.. note:: Some of the factors may be ``None`` if they are trivial.
	"""
	psi, phi = random_conjugate_pair(num_expansions, signature)
	psi_p, psi_i = psi.free_factors()
	phi_p, phi_i = phi.free_factors()
	return psi_p, psi_i, phi_p, phi_i

@needs_defaults
def random_conjugate_periodic_factors(num_expansions, signature):
	r"""Calls :func:`random_conjugate_factors` but returns only the peroidic factors. This method returns :math:`\psi_P, \phi_P` and ensures they are non-trivial.`"""
	psi_p = phi_p = None
	while psi_p is None or phi_p is None:
		psi_p, _, phi_p, _ = random_conjugate_factors()
	assert isinstance(psi_p, PeriodicFactor)
	return psi_p, phi_p

@needs_defaults
def random_conjugate_infinite_factors(num_expansions, signature):
	r"""Calls :func:`random_conjugate_factors` but returns only the infinite factors. This method returns :math:`\psi_I, \phi_I` and ensures they are non-trivial.`"""
	psi_i = phi_i = None
	while psi_i is None or phi_i is None:
		_, psi_i, _, phi_i = random_conjugate_factors()
	assert isinstance(psi_i, InfiniteFactor)
	return psi_i, phi_i